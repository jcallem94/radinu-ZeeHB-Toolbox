10c10
< //#define V0  (0.001)
---
> #define V0  (0.001)
14,16d13
< 
< static double Mcdm0;
< 
20d16
< 
24c20
< 
---
> static char WIMP[30],aWIMP[30];
38,39c34,35
< double Zi(int i) { return log(1.E-7)*pow((double)(i-1)/(double)(NZ),1.5) ;}
< static  int Iz(double z) { return NZ*pow(z/log(1.E-7),1./1.5)+1; }
---
> double Zi(int i) { return log(1.E-7)*pow((double)(i)/(double)(NZ),1.5) ;}
> static  int Iz(double z) { return NZ*pow(z/log(1.E-7),1./1.5); }
135c131
<   if(err_code) return 0;
---
> if(err_code) return 0;
143c139
< { double r;
---
> {  double r;
145c141
<    if(pmass[ix]>1.E-3*Mcdm0 && pmass[iX]>1.E-3*Mcdm0  ) 
---
>    if(pmass[ix]>1.E-3*Mcdm && pmass[iX]>1.E-3*Mcdm  ) 
164c160
<   if(E+sqrt(E*E + ms*ms)>=1.999999*Mcdm0) return 0;
---
>   if(E+sqrt(E*E + ms*ms)>=1.999999*Mcdm) return 0;
166c162
<   eps=ms/2/Mcdm0;
---
>   eps=ms/2/Mcdm;
169c165
<   { double subtract=0,norm=0,x=E/Mcdm0;
---
>   { double subtract=0,norm=0,x=E/Mcdm;
172,173c168,169
<      if(pmass[ix]>1.E-3*Mcdm0 && pmass[iX]>1.E-3*Mcdm0 ) csmax=1; else csmax=0.999;
<      pcm=decayPcm(2*Mcdm0*sqrt(1-x),pmass[ix],pmass[iX]);
---
>      if(pmass[ix]>1.E-3*Mcdm && pmass[iX]>1.E-3*Mcdm ) csmax=1; else csmax=0.999;
>      pcm=decayPcm(2*Mcdm*sqrt(1-x),pmass[ix],pmass[iX]);
181c177
<        pcm0=decayPcm(2*Mcdm0,pmass[ix],pmass[iX]);
---
>        pcm0=decayPcm(2*Mcdm,pmass[ix],pmass[iX]);
195,197c191,193
<   Egamma=2*Mcdm0*(1-Xe)/(1+cs);
<   if(Egamma<X0*Mcdm0) return 0;
<   if(Egamma/Mcdm0 -(1-Xe) < -1.E-4) return 0;
---
>   Egamma=2*Mcdm*(1-Xe)/(1+cs);
>   if(Egamma<X0*Mcdm) return 0;
>   if(Egamma/Mcdm -(1-Xe) < -1.E-4) return 0;
210c206
<    xe=Xe=E/Mcdm0; 
---
>    xe=Xe=E/Mcdm; 
213c209
<      return   ((x2-xe)*dSigmadEe(x1*Mcdm0) + (xe-x1)*dSigmadEe(x2*Mcdm0))/(x2-x1);
---
>      return   ((x2-xe)*dSigmadEe(x1*Mcdm) + (xe-x1)*dSigmadEe(x2*Mcdm))/(x2-x1);
278c274
<      if(Spectra[0] && dSigmadE(X1*Mcdm0) > X1CUT*dSigmadE_x1 )
---
>      if(Spectra[0] && dSigmadE(X1*Mcdm) > X1CUT*dSigmadE_x1 )
280c276
<         dSigmadE_x0=3*X0*(dSigmadE(X0*Mcdm0)+dSigmadE(3*X0*Mcdm0)-2*dSigmadE(2*X0*Mcdm0));
---
>         dSigmadE_x0=3*X0*(dSigmadE(X0*Mcdm)+dSigmadE(3*X0*Mcdm)-2*dSigmadE(2*X0*Mcdm));
284c280
<         displayFunc(dSigmadERest, Mcdm0*X0, Mcdm0,buff);
---
>         displayFunc(dSigmadERest, Mcdm*X0, Mcdm,buff);
291c287
<          { dSigmaDz=x*Mcdm0*dSigmadERest(x*Mcdm0);
---
>          { dSigmaDz=x*Mcdm*dSigmadERest(x*Mcdm);
302a299
> 
305c302
<        code[0]==code[1] && spin2Dm==1 && dSigmadEe(X1*Mcdm0) > X1CUT*dSigmadE_x1_e  ) 
---
>        code[0]==code[1] && spin2Dm==1 && dSigmadEe(X1*Mcdm) > X1CUT*dSigmadE_x1_e  ) 
309c306
<   displayFunc(dSigmadEe, Mcdm0*X0, Mcdm0," electron spectrum");
---
>   displayFunc(dSigmadEe, Mcdm*X0, Mcdm," electron spectrum");
311,314c308,311
<   csA=simpson(dSigmadE,Mcdm0*X0,Mcdm0,1.E-3);
<   csE=simpson(dSigmadEe,Mcdm0*X0,Mcdm0,1.E-3);
<   xcsA=simpson(EdSigmadERest,Mcdm0*X0,Mcdm0,1.E-3);
<   xcsE=simpson(EdSigmadEe,Mcdm0*X0,Mcdm0,1.E-3);
---
>   csA=simpson(dSigmadE,Mcdm*X0,Mcdm,1.E-3);
>   csE=simpson(dSigmadEe,Mcdm*X0,Mcdm,1.E-3);
>   xcsA=simpson(EdSigmadERest,Mcdm*X0,Mcdm,1.E-3);
>   xcsE=simpson(EdSigmadEe,Mcdm*X0,Mcdm,1.E-3);
317c314
<   printf("energy  fraction lost %E\n", (2*Mcdm0- xcsA/csA-2*xcsE/csA)/Mcdm0);  
---
>   printf("energy  fraction lost %E\n", (2*Mcdm- xcsA/csA-2*xcsE/csA)/Mcdm);  
320a318
> 
323,324c321,323
<          double Ee=Mcdm0*exp(Zi(i));
<          if(Ee>X0*Mcdm0) Spectra[1][i]+=Ee*dSigmadEe(Ee);
---
>          double Ee=Mcdm*exp(Zi(i));
>          if(Ee>X0*Mcdm) Spectra[1][i]+=Ee*dSigmadEe(Ee);
>          
326c325,327
<      }         
---
>        
>      }
>               
411c412
<    if(j0<1) j0=1;
---
>    if(j0<0) j0=0;
434,437c435,438
<      case 14: case 15: case 16: case 17: if(i0<5)
<       { i0=6; for(l=1;l<NZ;l++) tab[l]=phidiff[CHin][CHout][i0][l-1]; tab[0]=Nmass; return; }
<      case 10: case 11: case 12: case 13: if(i0<7)
<       { i0=9; for(l=0;l<NZ;l++) tab[l]=phidiff[CHin][CHout][i0][l-1]; tab[0]=Nmass; return; }
---
>      case 14: case 15: case 16: case 17: if(i0<5) 
>      { i0=6;  for(l=0;l<NZ;l++) tab[l]=phidiff[CHin][CHout][i0][l]; return;}
>      case 10: case 11: case 12: case 13: if(i0<7) 
>      { i0=9;  for(l=0;l<NZ;l++) tab[l]=phidiff[CHin][CHout][i0][l]; return;}
438a440,441
>    
> 
441c444
<    if(i0==NEn-1) for(l=1;l<NZ;l++) tab[l]= p0[l-1];
---
>    if(i0==NEn-1) for(l=0;l<NZ;l++) tab[l]= p0[l];
446c449
<      for(l=1;l<NZ;l++) tab[l]= c0*p0[l-1]+c1*p1[l-1];
---
>      for(l=0;l<NZ;l++) tab[l]= c0*p0[l]+c1*p1[l];
448d450
<    tab[0]=Nmass;
451,452d452
< 
< 
460,461c460,467
<   if(Ntot)*Ntot=simpson(FUNN, log(Xmin), 0.,1.E-4);
<   if(Xtot)*Xtot=simpson(FUNE, log(Xmin), 0.,1.E-4);
---
>   if(Xmin>=1) 
>   { if(Ntot)*Ntot=0;
>     if(Xtot)*Xtot=0;
>   } else 
>   {  
>     if(Ntot)*Ntot=simpson(FUNN, log(Xmin), 0.,1.E-4);
>     if(Xtot)*Xtot=simpson(FUNE, log(Xmin), 0.,1.E-4);
>   }  
474c480
< static void boost(double Y, double Emax, double mDecay, double mx, double*tab)
---
> void boost(double Y, double Emax, double mDecay, double mx, double*tab)
478a485,486
>   if(Y<0.01) return;
>   
483c491
<   for(l=1;l<NZ;l++)
---
>   for(l=0;l<NZ;l++)
502,503c510
<   for(l=1;l<NZ;l++) tab[l]=tab_out[l];
<   tab[0]=Emax;
---
>   for(l=0;l<NZ;l++) tab[l]=tab_out[l];
509c516
< int basicSpectra(double Mass, int pdgN, int outN, double * tab)
---
> int basicSpectra(int pdgN, int outN, double * tab)
527c534
<    if(inP!=25) mInterp(Mass,inP,outN,tab); else
---
>   if(inP!=25) mInterp(Mcdm,inP,outN,tab); else
533,543c540,549
<     mInterp(Mh,5,outN,tabV);  for(i=1;i<NZ;i++) tab[i]+=2*br_b*tabV[i];
<     mInterp(Mh,9,outN,tabV);  for(i=1;i<NZ;i++) tab[i]+=2*br_l*tabV[i];
<     mInterp(Mh,10,outN,tabV); for(i=1;i<NZ;i++) tab[i]+=2*br_Z*tabV[i];
<     mInterp(Mh,13,outN,tabV); for(i=1;i<NZ;i++) tab[i]+=2*br_W*tabV[i];
<     mInterp(Mh,0,outN,tabV);  for(i=1;i<NZ;i++) tab[i]+=2*br_G*tabV[i]; 
<     mInterp(Mh,4,outN,tabV);  for(i=1;i<NZ;i++) tab[i]+=2*br_c*tabV[i];
<     mInterp(Mh,4,outN,tabV);  for(i=1;i<NZ;i++) tab[i]+=2*br_c*tabV[i];
<     if(outN==0) tab[1]+=br_A*8/(Zi(1)-Zi(2));
<     tab[0]=Mass;
<     Y=acosh(Mcdm0/Mh);
<     boost(Y, Mcdm0,Mh , outMass[outN], tab); 
---
>     mInterp(Mh,5,outN,tabV);  for(i=0;i<NZ;i++) tab[i]+=2*br_b*tabV[i];
>     mInterp(Mh,9,outN,tabV);  for(i=0;i<NZ;i++) tab[i]+=2*br_l*tabV[i];
>     mInterp(Mh,10,outN,tabV); for(i=0;i<NZ;i++) tab[i]+=2*br_Z*tabV[i];
>     mInterp(Mh,13,outN,tabV); for(i=0;i<NZ;i++) tab[i]+=2*br_W*tabV[i];
>     mInterp(Mh,0,outN,tabV);  for(i=0;i<NZ;i++) tab[i]+=2*br_G*tabV[i]; 
>     mInterp(Mh,4,outN,tabV);  for(i=0;i<NZ;i++) tab[i]+=2*br_c*tabV[i];
>     mInterp(Mh,4,outN,tabV);  for(i=0;i<NZ;i++) tab[i]+=2*br_c*tabV[i];
>     if(outN==0) tab[0]+=br_A*8/(Zi(0)-Zi(1));
>     Y=acosh(Mcdm/Mh);
>     boost(Y, Mcdm,Mh , outMass[outN], tab); 
545,550d550
<    
< /*
< { int i; 
< for(i=1;i<NZ;i++) printf("%E\n", tab[i]);}
< exit(0);  
< */ 
554a555
> 
560c561,562
<   GG=sqrt(4*M_PI*parton_alpha(2*Mcdm0));
---
>   
>   GG=sqrt(4*M_PI*parton_alpha(2*Mcdm));
562,564c564
<   tab[0]=M/2;
<   for(i=1;i<NZ;i++) tab[i]=0;
<    
---
>   for(i=0;i<NZ;i++) tab[i]=0; 
592c592
<         for(i=1;i<NZ;i++) tab[i]=(1-lng)*tab[i]+lng*tabL[i];
---
>         for(i=0;i<NZ;i++) tab[i]=(1-lng)*tab[i]+lng*tabL[i];
608,614c608,612
<     mm[1]=m2;
<     
<     if(M>m1+m2)
<     { p2=sqrt((M*M-(m1+m2)*(m1+m2))*(M*M-(m1-m2)*(m1-m2)))/(2*M);
< //      printf("p2==%E ( %E -> %e %e)\n", p2,M,m1,m2);    
<     } else 
<     { p2=0;
---
>     mm[1]=m2;            
>       
>     if(M>m1+m2) p2=sqrt((M*M-(m1+m2)*(m1+m2))*(M*M-(m1-m2)*(m1-m2)))/(2*M);
>     else 
>     { p2=0; 
617,619c615,618
<         if(N1==23 || abs(N1)==24) mm[0]=M-m2; else mm[1]=M-m1;
<       }  
<     } 
---
>          if(N1==23 || abs(N1)==24)   mm[0]=M-m2; else mm[1]=M-m1;
>       }   
>     }
>     
622,623c621,622
<     
<     for(i=1;i<NZ;i++) tab[i]=0;
---
> 
>     for(i=0;i<NZ;i++) tab[i]=0;
645,646c644,645
<            { int i=Iz(log(2*p2/M)); if(i<=0)i=1;
<              if(i>1) tab[i]+=2/(Zi(i-1)-Zi(i+1)); else tab[i]+=2/(Zi(1)-Zi(2));
---
>            { int i=Iz(log(2*p2/M)); if(i<0)i=0;
>              if(i) tab[i]+=2/(Zi(i-1)-Zi(i+1)); else tab[i]+=2/(Zi(0)-Zi(1));
652c651
<       { double dY=log(M/E[k]/2);
---
>       { 
654,655c653,657
<         for(i=1;i<NZ;i++)tab[i]+=0.5*zInterp(Zi(i)+dY,tabAux);
<         tab[0]=M/2;
---
>         for(i=0;i<NZ;i++)
>         {  double e=M/2*exp(Zi(i));
>            double z=log(e/E[k]);
>            if(z<=0) tab[i]+=0.5*zInterp(z,tabAux);
>         }  
677,680c679,685
<         procInfo1(d2Proc,&ntot,NULL,NULL);      
<         for(l=1;l<=ntot ;l++)
<         {    
<           double wP=pWidth2(d2Proc,l);
---
>         procInfo1(d2Proc,&ntot,NULL,NULL);
>         {  double  Qstat;
>            if(Qaddress) { Qstat=*Qaddress; setQforParticle(Qaddress,nn[k]);}
>    
>            for(l=1;l<=ntot ;l++)
>            {    
>              double wP=pWidth2(d2Proc,l);
682,695c687,701
<           if(wP>0)
<           { int N2=d2Proc->interface->pinfAux(l,2,NULL,NULL,NULL);
<             int N3=d2Proc->interface->pinfAux(l,3,NULL,NULL,NULL);
<             N2=stdPDG(N2);
<             N3=stdPDG(N3); 
<             procInfo2(d2Proc,l,n,m);    
<             getSpectrum(0,m[0],m[1],m[2],n[1],n[2],N2,N3,outP, tab_p);
<             for(i=1;i<NZ;i++) tabAux[i]+=wP*tab_p[i];
<             w+=wP;
<           }
<         }
<         tabAux[0]=m[0]/2; 
<         if(w==0) { fprintf(stderr,"Can not find decays for  %s\n",nn[k]);
<                                continue;
---
>              if(wP>0)
>              { int N2=d2Proc->interface->pinfAux(l,2,NULL,NULL,NULL);
>                int N3=d2Proc->interface->pinfAux(l,3,NULL,NULL,NULL);
>                N2=stdPDG(N2);
>                N3=stdPDG(N3); 
>                procInfo2(d2Proc,l,n,m);    
>                getSpectrum(0,m[0],m[1],m[2],n[1],n[2],N2,N3,outP, tab_p);
>                for(i=0;i<NZ;i++) tabAux[i]+=wP*tab_p[i];
>                w+=wP;
>              }
>            }
>            if(Qaddress){ *Qaddress=Qstat; calcMainFunc();}           
>         } 
>         if(w==0) { if( abs(pNum(nn[k])) != abs(pNum(CDM)))   fprintf(stderr,"Can't find decays for  %s\n",nn[k]);
>                    continue;
698,699d703
<         for(i=1;i<NZ;i++)tab[i]+=tabAux[i]/w;
< // if(outP==2) displaySpectrum(tabAux,"before boost", 1.,180.,1);                
701,702c705
< //  if(outP==2)printf("EE=%E (%E) mm=%E(%E) p2=%E boost=%E\n",E[k],E[1-k],mm[k],mm[1-k],p2,Y);        
< // if(outP==2)displaySpectrum(tabAux,"after boost", 1.,180.,1);         
---
>         for(i=0;i<NZ;i++)tab[i]+=tabAux[i]/w;
706,712d708
< /*  
<   if(outP==2)
<   { char txt[40];
<     sprintf(txt, "  a-prot %E-> %s %s",M, n1,n2);  
<     displaySpectrum(tab,txt, 1, 180.,1); 
<   }
< */    
715,723c711
< void sumSpectra(double*A,double*B,double*S)
< { double s[NZ],E,z;
<   int i;
<   if(A[0]==B[0]) {s[0]=A[0]; for(i=1;i<NZ;i++) s[i]=A[i]+B[i];}  else
<   if(A[0]>B[0]) for( s[0]=A[0],i=1;i<NZ;i++) { z=Zi(i)+log(A[0]/B[0]); if(z<=0) s[i]+=zInterp(z,B); }
<    else         for(s[0]=B[0],i=1;i<NZ;i++)  { z=Zi(i)+log(B[0]/A[0]); if(z<=0) s[i]+=zInterp(z,A); }
<    
<   for(i=0;i<NZ;i++) S[i]=s[i];
< }
---
> 
734,735c722,723
<     
<   for(l=0;l<6;l++) if(Spectra[l]) { Spectra[l][0]=Mcdm0; for(i=1;i<NZ;i++) Spectra[l][i]=0;}  
---
>   
>   for(l=0;l<6;l++) if(Spectra[l]) for(i=0;i<NZ;i++) Spectra[l][i]=0;  
794c782
<       r=v0*cs23(cc23,1,v0*Mcdm0/2,i3W)/br;
---
>       r=v0*cs23(cc23,1,v0*Mcdm/2,i3W)/br;
800c788
<         r*=decayPcmW(2*Mcdm0,m[l],m[l_],wV,wV2,0)/decayPcmW(2*Mcdm0,m[l],m[l_],wV,0.,0);
---
>         r*=decayPcmW(2*Mcdm,m[l],m[l_],wV,wV2,0)/decayPcmW(2*Mcdm,m[l],m[l_],wV,0,0);
803c791
<       v_cs[k]=r; 
---
>       v_cs[k]=r;
811d798
< 
814a802
> //printf("Mb4=%E\n", findValW("Mb")); 
838,839c826,827
<        double m1=m[2], m2=m[3], Eg=X1*Mcdm0;
<        double kappa=4*Mcdm0*(Mcdm0-Eg), ms=m1+m2, md=m1-m2;
---
>        double m1=m[2], m2=m[3], Eg=X1*Mcdm;
>        double kappa=4*Mcdm*(Mcdm-Eg), ms=m1+m2, md=m1-m2;
841c829
<        {  double dp=(Mcdm0-Eg/2)*sqrt((1-ms*ms/kappa)*(1-md*md/kappa));
---
>        {  double dp=(Mcdm-Eg/2)*sqrt((1-ms*ms/kappa)*(1-md*md/kappa));
845,846c833,834
<           double Q1=Mcdm0*Mcdm0+m1*m1-2*Mcdm0*E1;
<           double Q2=Mcdm0*Mcdm0+m2*m2-2*Mcdm0*E2;             
---
>           double Q1=Mcdm*Mcdm+m1*m1-2*Mcdm*E1;
>           double Q2=Mcdm*Mcdm+m2*m2-2*Mcdm*E2;             
848c836
<           double  m_min=10*Mcdm0;
---
>           double  m_min=10*Mcdm;
852,853c840,841
< printf("energy conservation:0=%E=%E\n",  (E1+Eg+sqrt(pow(p2+2*dp,2)+m2*m2))/2/Mcdm0-1   ,
<                                                    (E2+Eg+sqrt(pow(p1+2*dp,2)+m1*m1))/2/Mcdm0-1 );
---
> printf("energy conservation:0=%E=%E\n",  (E1+Eg+sqrt(pow(p2+2*dp,2)+m2*m2))/2/Mcdm-1   ,
>                                                    (E2+Eg+sqrt(pow(p1+2*dp,2)+m1*m1))/2/Mcdm-1 );
858,862c846,849
<           }
< 
<           if(  m_min*m_min -Q1  < QCUT*Mcdm0*Mcdm0*abs(charge3[0])/3.  
<             || m_min*m_min -Q2  < QCUT*Mcdm0*Mcdm0*abs(charge3[1])/3. 
<             || (abs(pdg[0])==24 && abs(pdg[1])==24  && Mcdm0 > 500 && v_cs[k]>1.E-3*vcsSum ))
---
>           }  
>           if(  m_min*m_min -Q1  < QCUT*Mcdm*Mcdm*abs(charge3[0])/3.  
>             || m_min*m_min -Q2  < QCUT*Mcdm*Mcdm*abs(charge3[1])/3. 
>             || (abs(pdg[0])==24 && abs(pdg[1])==24  && Mcdm > 500 && v_cs[k]>1.E-3*vcsSum ))
867a855,856
> //printf("m_min*m_min -Q1 =%E proc=%s   ch=%E\n", m_min*m_min -Q1,new22A->txt,charge3[0]/3.); 
> 
894c883
<          for(i=1;i<NZ;i++) Spectra[l][i]+=tab2[i]*v_cs[k];
---
>          for(i=0;i<NZ;i++) Spectra[l][i]+=tab2[i]*v_cs[k];
899c888
<           for(l=0;l<2;l++) if(addGamma(pdg[l])&& m[2+l]!=0.) for(i=1;i<NZ;i++)
---
>           for(l=0;l<2;l++) if(addGamma(pdg[l])&& m[2+l]!=0.) for(i=0;i<NZ;i++)
901c890
<              if(2*Mcdm0*sqrt(1-x) > m[2]+m[3])
---
>              if(2*Mcdm*sqrt(1-x) > m[2]+m[3])
903c892
<                 pcm=decayPcm(2*Mcdm0*sqrt(1-x), m[2],m[3]); 
---
>                 pcm=decayPcm(2*Mcdm*sqrt(1-x), m[2],m[3]); 
914,915c903
<     }
<      
---
>     } 
922,923c910,911
< double calcSpectrum(char * WINP, int key, double *Sg,double*Se, double*Sp, double*Sne,double*Snm,double*Snl, int *errcode)
< { int n,i,j,l,err;
---
> double calcSpectrum(int key, double *Sg,double*Se, double*Sp, double*Sne,double*Snm,double*Snl, int *errcode)
> { int n,i,l,err,j;
925d912
<   char  lop[20];
931,932d917
<   
<   Mcdm0=pMass(WINP);
934,935c919
<     
<   if(assignVal("Q",2*Mcdm0)==0) calcMainFunc() ; 
---
>   if(assignVal("Q",2*Mcdm)==0) calcMainFunc() ; 
940c924
<   if(key&4) { PrintOn=1; printf("    Channel          vcs[cm^3/s]\n");} else PrintOn=0;  
---
>   PrintOn= (key&4);  
945c929
<   for(l=0;l<6;l++)if(Spectra[l]) { Spectra[l][0]=Mcdm0; for(i=1;i<NZ;i++) Spectra[l][i]=0;}  
---
>   for(l=0;l<6;l++)if(Spectra[l]) for(i=0;i<NZ;i++) Spectra[l][i]=0;  
953,959c937,941
<           
<                                             
<   for(i=0;i<nModelParticles;i++) if(strcmp(WINP,ModelPrtcls[i].name)==0||strcmp(WINP,ModelPrtcls[i].aname)==0)
<   { name=ModelPrtcls[i].name; aname=ModelPrtcls[i].aname; break;} 
< 
<   if(i==nModelParticles) return -1;
< 
---
>   name=CDM;
>   aname=pdg2name(-pNum(CDM));
>   if(!aname) aname=CDM;
>   strcpy(WIMP,name);
>   strcpy(aWIMP,aname);
961,963c943,944
<   
<   if(Spectra[0]) dSigmadE_x1=zInterp(log(X1),Spectra[0])/(X1*Mcdm0);
<   if(Spectra[1]) dSigmadE_x1_e=zInterp(log(X1),Spectra[1])/(X1*Mcdm0);
---
>   if(Spectra[0]) dSigmadE_x1=zInterp(log(X1),Spectra[0])/(X1*Mcdm);
>   if(Spectra[1]) dSigmadE_x1_e=zInterp(log(X1),Spectra[1])/(X1*Mcdm);
968d948
< 
989c969,970
<     c=2/(1+exp(dmAsymm))/(1+exp(-dmAsymm)); 
---
>     c=(1+dmAsymm)*(1-dmAsymm)/2;
>     
991c972
<     for(l=0;l<6;l++) if(Spectra[l])for(i=1;i<NZ;i++)Spectra[l][i]*=c;
---
>     for(l=0;l<6;l++) if(Spectra[l])for(i=0;i<NZ;i++)Spectra[l][i]*=c;
994,995c975,976
<     
<     c=1/(1+exp(-dmAsymm))/(1+exp(-dmAsymm));     
---
>      
>     c=(1+dmAsymm)*(1+dmAsymm)/4;
997c978
<     for(l=0;l<6;l++) if(Spectra[l])for(i=1;i<NZ;i++)Spectra[l][i]+= Spectra_[l][i]*c;
---
>     for(l=0;l<6;l++) if(Spectra[l])for(i=0;i<NZ;i++)Spectra[l][i]+= Spectra_[l][i]*c;
1001c982
<     c=1/(1+exp(dmAsymm))/(1+exp(dmAsymm));
---
>     c=(1-dmAsymm)*(1-dmAsymm)/4;
1003c984
<     for(l=0;l<6;l++) if(Spectra[l])for(i=1;i<NZ;i++)Spectra[l][i]+= Spectra_[l][i]*c;
---
>     for(l=0;l<6;l++) if(Spectra[l])for(i=0;i<NZ;i++)Spectra[l][i]+= Spectra_[l][i]*c;
1005a987,992
>   
>   if(vcs)
>   { for(l=0;l<6;l++) if(Spectra[l])for(i=0;i<NZ;i++)Spectra[l][i]/=vcs;
>     for(i=0;i<nAnCh;i++) vSigmaCh[i].weight/= vcs;
>   }  
> 
1008c995
<   for(j=0;j<5;j++) vSigmaCh[nAnCh].prtcl[j]=NULL;
---
>   for(j=0;j<5;j++) vSigmaCh[nAnCh].prtcl[j]=NULL;                                       
1017,1023c1004,1006
<  
<   if(vcs)
<   {  for(l=0;l<6;l++) if(Spectra[l])for(i=1;i<NZ;i++)Spectra[l][i]/=vcs;
<      for(i=0;i<nAnCh;i++) vSigmaCh[i].weight/= vcs;
<   } 
<   
<   
---
>     
> 
> 
1029,1030c1012,1013
<     printf("==================================\n annihilation cross section %.2E cm^3/s\n",vcs  );
<     printf(" conrtibution of processes\n");     
---
>     printf("\n Annihilation cross section %.2E cm^3/s\n",vcs  );
>     printf("   Channel           Contribution \n");     
1041d1023
< 
1043c1025
<   if(Mcdm0 < 2) printf("WARNING! Spectra obtained at Mcdm=2GeV are used !\n");	 
---
>   if(Mcdm < 2) printf("WARNING! Spectra obtained at Mcdm=2GeV are used !\n");	 
1048a1031,1038
> /*
> double oneChannelSpectrum(char* channel, int key, double *Sg,double*Se, double*Sp, double*Sne,double*Snm,double*Snl, int *errcode)
> {
>    
> 
> }
> */
> 
1052,1053c1042
<   if(E>tab[0]) return 0;
<   z=log(E/tab[0]); 
---
>   z=log(E/Mcdm); 
1057c1046
< int displaySpectrum(double*tab, char*mess,double Emin,double Emax)
---
> int displaySpectrum(double*tab, char*mess,double Emin,double Emax,int EU)
1061,1062c1050,1061
<   for(i=0;i<NZ;i++) f[i]=SpectdNdE(Emin+i*(Emax-Emin)/(NZ-1),tab);
<   displayPlot(mess, "E[GeV]", "dN/dE", Emin, Emax,NZ,f,NULL);
---
> 
>   
>   if(EU)
>   {  for(i=0;i<NZ;i++) f[i]=SpectdNdE(Emin+i*(Emax-Emin)/(NZ-1),tab);
>      displayPlot(mess, "E[GeV]", "dN/dE", Emin, Emax,NZ,f,NULL);
>   }
>   else
>   {  double x;
>      double Xmin=Emin/Mcdm, Xmax=Emax/Mcdm;
>      for(i=0;i<NZ;i++){ x= log10(Xmin) + i*log10(Xmax/Xmin)/(NZ-1);  f[i]=zInterp(log(10.)*x ,tab)*log(10.);}
>      displayPlot(mess, "x=log10(E/Mcmd)", "dN/dx", log10(Emin/Mcdm), log10(Emax/Mcdm),NZ, f,NULL);
>   }
1066,1088c1065,1066
< void addSpectrum(double *Spect, double * toAdd)
< {
<   double m1=Spect[0];
<   double m2=toAdd[0];
<   double buff[NZ];
<   int i;
<     
<   if(m1>m2) for(i=1;i<NZ;i++) 
<   { 
<      double E= m1*exp(Zi(i));
<      if(E>m2) return; 
<      Spect[i]+=  SpectdNdE(E,toAdd)*E;  
<   } else  
<   { for(i=0;i<NZ;i++) buff[i]=Spect[i];
<     for(i=0;i<NZ;i++) Spect[i]=toAdd[i];
<     for(i=1;i<NZ;i++) 
<     {  
<        double E= m2*exp(Zi(i));    
<        if(E>m1) return;
<        Spect[i]+=  SpectdNdE(E,buff)*E;
<     } 
<   }
< } 
---
>   
> 
